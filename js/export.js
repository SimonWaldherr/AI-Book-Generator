/**
 * Export module for AI Book Generator
 * Handles various export formats and file generation
 */

import { CONFIG } from './config.js';
import { showAlert } from './ui.js';

class ExportManager {
    constructor() {
        this.bookData = null;
    }

    setBookData(data) {
        this.bookData = data;
    }

    // Text export
    exportAsText() {
        if (!this.bookData) {
            showAlert('No book data to export', 'error');
            return;
        }
        const textContent = this.generateTextContent();
        this.downloadFile(textContent, 'book.txt', CONFIG.EXPORT_FORMATS.TXT);
    }

    generateTextContent() {
        let content = '';
        const title = this.bookData.title || 'AI Generated Book';
        content += `${title}\n` + '='.repeat(title.length) + '\n\n';
        if (this.bookData.concept) {
            content += 'CONCEPT\n-------\n' + this.bookData.concept + '\n\n';
        }
        if (this.bookData.tableOfContents) {
            content += 'TABLE OF CONTENTS\n-----------------\n' + this.bookData.tableOfContents + '\n\n';
        }
        if (this.bookData.chapters && this.bookData.chapters.length > 0) {
            content += 'CHAPTERS\n--------\n\n';
            this.bookData.chapters.forEach((chapter, index) => {
                content += `Chapter ${index + 1}: ${chapter.title}\n`;
                content += '-'.repeat(`Chapter ${index + 1}: ${chapter.title}`.length) + '\n';
                content += this.stripHtml(chapter.content) + '\n\n';
            });
        }
        content += `\n\nGenerated by AI Book Generator on ${new Date().toLocaleString()}`;
        return content;
    }

    // HTML export
    exportAsHtml() {
        if (!this.bookData) {
            showAlert('No book data to export', 'error');
            return;
        }
        const htmlContent = this.generateHtmlContent(true);
        this.downloadFile(htmlContent, 'book.html', CONFIG.EXPORT_FORMATS.HTML);
    }

    generateHtmlContent(includeStyles = false) {
        const title = this.bookData.title || 'AI Generated Book';
        const styles = includeStyles ? `
        <style>
            body { font-family: 'Georgia', serif; line-height: 1.6; max-width: 800px; margin: 0 auto; padding: 20px; color: #333; }
            .book-title { text-align: center; font-size: 2.5em; margin-bottom: .5em; color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 20px; }
            .concept { background:#f8f9fa; padding:20px; border-left: 4px solid #3498db; margin:20px 0; }
            .table-of-contents { background:#fff; padding:20px; border:1px solid #ddd; margin:20px 0; white-space:pre-wrap; }
            .chapter { margin: 40px 0; page-break-before: always; }
            .chapter-title { color:#2c3e50; border-bottom:2px solid #3498db; padding-bottom:10px; margin-bottom:20px; }
            .chapter-content { text-align: justify; }
            .footer { margin-top: 50px; padding-top: 20px; border-top:1px solid #ddd; text-align:center; color:#666; font-size:.9em; }
            .cover { text-align:center; margin: 10px 0 30px; }
            .cover img { max-width:100%; height:auto; border-radius:8px; box-shadow: 0 4px 12px rgba(0,0,0,.15); }
            @media print { .chapter { page-break-before: always; } }
        </style>` : '';

        let html = `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>${this.escapeHtml(title)}</title>${styles}
</head><body>`;

        html += `<h1 class="book-title">${this.escapeHtml(title)}</h1>`;

        if (this.bookData.coverImage) {
            html += `<div class="cover"><img src="${this.bookData.coverImage}" alt="Book cover"></div>`;
        }
        if (this.bookData.concept) {
            html += `<div class="concept"><h2>Concept</h2><p>${this.escapeHtml(this.bookData.concept).replace(/\n/g, '</p><p>')}</p></div>`;
        }
        if (this.bookData.tableOfContents) {
            html += `<div class="table-of-contents"><h2>Table of Contents</h2><pre>${this.escapeHtml(this.bookData.tableOfContents)}</pre></div>`;
        }
        if (this.bookData.chapters && this.bookData.chapters.length > 0) {
            this.bookData.chapters.forEach((chapter, index) => {
                html += `<div class="chapter">
                    <h2 class="chapter-title">Chapter ${index + 1}: ${this.escapeHtml(chapter.title)}</h2>
                    <div class="chapter-content">${chapter.content}</div>
                </div>`;
            });
        }
        html += `<div class="footer">Generated by AI Book Generator on ${new Date().toLocaleString()}</div></body></html>`;
        return html;
    }

    // Markdown export
    exportAsMarkdown() {
        if (!this.bookData) {
            showAlert('No book data to export', 'error');
            return;
        }
        const markdownContent = this.generateMarkdownContent();
        this.downloadFile(markdownContent, 'book.md', CONFIG.EXPORT_FORMATS.MARKDOWN);
    }

    generateMarkdownContent() {
        let markdown = '';
        if (this.bookData.title) markdown += `# ${this.bookData.title}\n\n`;
        if (this.bookData.coverImage) markdown += `![Cover](# "Cover image not embedded in MD export")\n\n`;
        if (this.bookData.concept) markdown += '## Concept\n\n' + this.bookData.concept + '\n\n';
        if (this.bookData.tableOfContents) {
            markdown += '## Table of Contents\n\n';
            const tocLines = this.bookData.tableOfContents.split('\n');
            tocLines.forEach((line, index) => {
                if (line.trim()) markdown += `${index + 1}. ${line.trim()}\n`;
            });
            markdown += '\n';
        }
        if (this.bookData.chapters && this.bookData.chapters.length > 0) {
            this.bookData.chapters.forEach((chapter, index) => {
                markdown += `## Chapter ${index + 1}: ${chapter.title}\n\n`;
                markdown += this.stripHtml(chapter.content) + '\n\n---\n\n';
            });
        }
        markdown += `*Generated by AI Book Generator on ${new Date().toLocaleString()}*\n`;
        return markdown;
    }

    // JSON export
    exportAsJson() {
        if (!this.bookData) {
            showAlert('No book data to export', 'error');
            return;
        }
        const jsonData = {
            ...this.bookData,
            metadata: {
                ...(this.bookData.metadata || {}),
                exportedAt: new Date().toISOString(),
                version: '2.1',
                generator: 'AI Book Generator'
            }
        };
        const jsonContent = JSON.stringify(jsonData, null, 2);
        this.downloadFile(jsonContent, 'book.json', CONFIG.EXPORT_FORMATS.JSON);
    }

    // PDF export (uses html2pdf.js if present, else print fallback)
    async exportAsPdf() {
        if (!this.bookData) {
            showAlert('No book data to export', 'error');
            return;
        }
        const html = this.generateHtmlContent(true);

        // Use html2pdf if available
        if (typeof window !== 'undefined' && window.html2pdf) {
            try {
                const container = document.createElement('div');
                container.style.position = 'fixed';
                container.style.left = '-10000px';
                container.innerHTML = html;
                document.body.appendChild(container);

                await window.html2pdf().set({
                    filename: 'book.pdf',
                    margin: 10,
                    image: { type: 'jpeg', quality: 0.95 },
                    html2canvas: { scale: 2, useCORS: true },
                    jsPDF: { unit: 'pt', format: 'a4', orientation: 'portrait' }
                }).from(container).save();

                document.body.removeChild(container);
                showAlert('PDF exported successfully!', 'success');
                return;
            } catch (e) {
                console.error(e);
                showAlert('PDF export failed, using print fallback.', 'warning');
            }
        }

        // Fallback to print
        const blob = new Blob([html], { type: 'text/html' });
        const url = URL.createObjectURL(blob);
        const printWindow = window.open(url, '_blank');
        const timer = setInterval(() => {
            if (printWindow && printWindow.document.readyState === 'complete') {
                clearInterval(timer);
                printWindow.focus();
                printWindow.print();
            }
        }, 300);
    }

    // Utility methods
    downloadFile(content, filename, mimeType) {
        try {
            const blob = new Blob([content], { type: mimeType + ';charset=utf-8' });
            const url = URL.createObjectURL(blob);
            const link = document.createElement('a');
            link.href = url;
            link.download = filename;
            link.style.display = 'none';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            setTimeout(() => URL.revokeObjectURL(url), 100);
            showAlert(`Book exported as ${filename}`, 'success');
        } catch (error) {
            console.error('Export failed:', error);
            showAlert('Export failed. Please try again.', 'error');
        }
    }

    stripHtml(html) {
        const tmp = document.createElement('div');
        tmp.innerHTML = html;
        return tmp.textContent || tmp.innerText || '';
    }

    escapeHtml(text) {
        const div = document.createElement('div');
        div.textContent = text;
        return div.innerHTML;
    }

    // Stats helpers
    getWordCount(chapters = this.bookData?.chapters || []) {
        return chapters.reduce((total, chapter) => {
            const text = this.stripHtml(chapter.content);
            return total + text.split(/\s+/).filter(w => w.length > 0).length;
        }, 0);
    }

    getReadingTime(wordCount = this.getWordCount()) {
        const averageWPM = 200;
        const minutes = Math.ceil(wordCount / averageWPM);
        if (minutes < 60) return `${minutes} minutes`;
        const hours = Math.floor(minutes / 60);
        const remainingMinutes = minutes % 60;
        return `${hours} hour${hours > 1 ? 's' : ''} ${remainingMinutes} minutes`;
    }

    getBookStatistics(bookData = this.bookData) {
        if (!bookData) return null;
        const chapters = bookData.chapters || [];
        const wordCount = this.getWordCount(chapters);
        const chapterCount = chapters.length;
        const averageChapterLength = chapterCount > 0 ? Math.round(wordCount / chapterCount) : 0;
        return {
            wordCount,
            chapterCount,
            averageChapterLength,
            readingTime: this.getReadingTime(wordCount),
            characterCount: chapters.reduce((total, chapter) => total + this.stripHtml(chapter.content).length, 0)
        };
    }
}

export const exportManager = new ExportManager();
